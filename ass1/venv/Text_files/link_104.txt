URL: https://docs.python.org/3/library/csv.html

Title: 14.1. csv — CSV File Reading and Writing — Python 3.5.2 documentation

Doc Id: 104

Meta Tags : No meta tag found in document

Date :Jun 27, 2016

Content :Source code: Lib/csv.py
The so-called CSV (Comma Separated Values) format is the most common import and
export format for spreadsheets and databases.  CSV format was used for many
years prior to attempts to describe the format in a standardized way in
RFC 4180.  The lack of a well-defined standard means that subtle differences
often exist in the data produced and consumed by different applications.  These
differences can make it annoying to process CSV files from multiple sources.
Still, while the delimiters and quoting characters vary, the overall format is
similar enough that it is possible to write a single module which can
efficiently manipulate such data, hiding the details of reading and writing the
data from the programmer.
The csv module implements classes to read and write tabular data in CSV
format.  It allows programmers to say, “write this data in the format preferred
by Excel,” or “read data from this file which was generated by Excel,” without
knowing the precise details of the CSV format used by Excel.  Programmers can
also describe the CSV formats understood by other applications or define their
own special-purpose CSV formats.
The csv module’s reader and writer objects read and
write sequences.  Programmers can also read and write data in dictionary form
using the DictReader and DictWriter classes.
See also
The csv module defines the following functions:
Return a reader object which will iterate over lines in the given csvfile.
csvfile can be any object which supports the iterator protocol and returns a
string each time its __next__() method is called — file objects and list objects are both suitable.   If csvfile is a file object,
it should be opened with newline=''. [1]  An optional
dialect parameter can be given which is used to define a set of parameters
specific to a particular CSV dialect.  It may be an instance of a subclass of
the Dialect class or one of the strings returned by the
list_dialects() function.  The other optional fmtparams keyword arguments
can be given to override individual formatting parameters in the current
dialect.  For full details about the dialect and formatting parameters, see
section Dialects and Formatting Parameters.
Each row read from the csv file is returned as a list of strings.  No
automatic data type conversion is performed unless the QUOTE_NONNUMERIC format
option is specified (in which case unquoted fields are transformed into floats).
A short usage example:
Return a writer object responsible for converting the user’s data into delimited
strings on the given file-like object.  csvfile can be any object with a
write() method.  If csvfile is a file object, it should be opened with
newline='' [1].  An optional dialect
parameter can be given which is used to define a set of parameters specific to a
particular CSV dialect.  It may be an instance of a subclass of the
Dialect class or one of the strings returned by the
list_dialects() function.  The other optional fmtparams keyword arguments
can be given to override individual formatting parameters in the current
dialect.  For full details about the dialect and formatting parameters, see
section Dialects and Formatting Parameters. To make it
as easy as possible to interface with modules which implement the DB API, the
value None is written as the empty string.  While this isn’t a
reversible transformation, it makes it easier to dump SQL NULL data values to
CSV files without preprocessing the data returned from a cursor.fetch* call.
All other non-string data are stringified with str() before being written.
A short usage example:
Associate dialect with name.  name must be a string. The
dialect can be specified either by passing a sub-class of Dialect, or
by fmtparams keyword arguments, or both, with keyword arguments overriding
parameters of the dialect. For full details about the dialect and formatting
parameters, see section Dialects and Formatting Parameters.
Delete the dialect associated with name from the dialect registry.  An
Error is raised if name is not a registered dialect name.
Return the dialect associated with name.  An Error is raised if
name is not a registered dialect name.  This function returns an immutable
Dialect.
Return the names of all registered dialects.
Returns the current maximum field size allowed by the parser. If new_limit is
given, this becomes the new limit.
The csv module defines the following classes:
Create an object which operates like a regular reader but maps the
information read into a dict whose keys are given by the optional
fieldnames parameter.  The fieldnames parameter is a sequence whose elements are associated with the fields of the
input data in order. These elements become the keys of the resulting
dictionary.  If the fieldnames parameter is omitted, the values in the
first row of the csvfile will be used as the fieldnames.  If the row read
has more fields than the fieldnames sequence, the remaining data is added as
a sequence keyed by the value of restkey.  If the row read has fewer
fields than the fieldnames sequence, the remaining keys take the value of
the optional restval parameter.  Any other optional or keyword arguments
are passed to the underlying reader instance.
A short usage example:
Create an object which operates like a regular writer but maps dictionaries
onto output rows.  The fieldnames parameter is a sequence of keys that identify the order in which values in the
dictionary passed to the writerow() method are written to the
csvfile.  The optional restval parameter specifies the value to be
written if the dictionary is missing a key in fieldnames.  If the
dictionary passed to the writerow() method contains a key not found in
fieldnames, the optional extrasaction parameter indicates what action to
take.  If it is set to 'raise' a ValueError is raised.  If it is
set to 'ignore', extra values in the dictionary are ignored.  Any other
optional or keyword arguments are passed to the underlying writer
instance.
Note that unlike the DictReader class, the fieldnames parameter
of the DictWriter is not optional.  Since Python’s dict
objects are not ordered, there is not enough information available to deduce
the order in which the row should be written to the csvfile.
A short usage example:
The Dialect class is a container class relied on primarily for its
attributes, which are used to define the parameters for a specific
reader or writer instance.
The excel class defines the usual properties of an Excel-generated CSV
file.  It is registered with the dialect name 'excel'.
The excel_tab class defines the usual properties of an Excel-generated
TAB-delimited file.  It is registered with the dialect name 'excel-tab'.
The unix_dialect class defines the usual properties of a CSV file
generated on UNIX systems, i.e. using '\n' as line terminator and quoting
all fields.  It is registered with the dialect name 'unix'.
New in version 3.2.
The Sniffer class is used to deduce the format of a CSV file.
The Sniffer class provides two methods:
Analyze the given sample and return a Dialect subclass
reflecting the parameters found.  If the optional delimiters parameter
is given, it is interpreted as a string containing possible valid
delimiter characters.
Analyze the sample text (presumed to be in CSV format) and return
True if the first row appears to be a series of column headers.
An example for Sniffer use:
The csv module defines the following constants:
Instructs writer objects to quote all fields.
Instructs writer objects to only quote those fields which contain
special characters such as delimiter, quotechar or any of the characters in
lineterminator.
Instructs writer objects to quote all non-numeric fields.
Instructs the reader to convert all non-quoted fields to type float.
Instructs writer objects to never quote fields.  When the current
delimiter occurs in output data it is preceded by the current escapechar
character.  If escapechar is not set, the writer will raise Error if
any characters that require escaping are encountered.
Instructs reader to perform no special processing of quote characters.
The csv module defines the following exception:
Raised by any of the functions when an error is detected.
To make it easier to specify the format of input and output records, specific
formatting parameters are grouped together into dialects.  A dialect is a
subclass of the Dialect class having a set of specific methods and a
single validate() method.  When creating reader or
writer objects, the programmer can specify a string or a subclass of
the Dialect class as the dialect parameter.  In addition to, or instead
of, the dialect parameter, the programmer can also specify individual
formatting parameters, which have the same names as the attributes defined below
for the Dialect class.
Dialects support the following attributes:
A one-character string used to separate fields.  It defaults to ','.
Controls how instances of quotechar appearing inside a field should
themselves be quoted.  When True, the character is doubled. When
False, the escapechar is used as a prefix to the quotechar.  It
defaults to True.
On output, if doublequote is False and no escapechar is set,
Error is raised if a quotechar is found in a field.
A one-character string used by the writer to escape the delimiter if quoting
is set to QUOTE_NONE and the quotechar if doublequote is
False. On reading, the escapechar removes any special meaning from
the following character. It defaults to None, which disables escaping.
The string used to terminate lines produced by the writer. It defaults
to '\r\n'.
Note
The reader is hard-coded to recognise either '\r' or '\n' as
end-of-line, and ignores lineterminator. This behavior may change in the
future.
A one-character string used to quote fields containing special characters, such
as the delimiter or quotechar, or which contain new-line characters.  It
defaults to '"'.
Controls when quotes should be generated by the writer and recognised by the
reader.  It can take on any of the QUOTE_* constants (see section
Module Contents) and defaults to QUOTE_MINIMAL.
When True, whitespace immediately following the delimiter is ignored.
The default is False.
When True, raise exception Error on bad CSV input.
The default is False.
Reader objects (DictReader instances and objects returned by the
reader() function) have the following public methods:
Return the next row of the reader’s iterable object as a list, parsed according
to the current dialect.  Usually you should call this as next(reader).
Reader objects have the following public attributes:
A read-only description of the dialect in use by the parser.
The number of lines read from the source iterator. This is not the same as the
number of records returned, as records can span multiple lines.
DictReader objects have the following public attribute:
If not passed as a parameter when creating the object, this attribute is
initialized upon first access or when the first record is read from the
file.
Writer objects (DictWriter instances and objects returned by
the writer() function) have the following public methods.  A row must be
an iterable of strings or numbers for Writer objects and a dictionary
mapping fieldnames to strings or numbers (by passing them through str()
first) for DictWriter objects.  Note that complex numbers are written
out surrounded by parens. This may cause some problems for other programs which
read CSV files (assuming they support complex numbers at all).
Write the row parameter to the writer’s file object, formatted according to
the current dialect.
Changed in version 3.5: Added support of arbitrary iterables.
Write all the rows parameters (a list of row objects as described above) to
the writer’s file object, formatted according to the current dialect.
Writer objects have the following public attribute:
A read-only description of the dialect in use by the writer.
DictWriter objects have the following public method:
Write a row with the field names (as specified in the constructor).
New in version 3.2.
The simplest example of reading a CSV file:
Reading a file with an alternate format:
The corresponding simplest possible writing example is:
Since open() is used to open a CSV file for reading, the file
will by default be decoded into unicode using the system default
encoding (see locale.getpreferredencoding()).  To decode a file
using a different encoding, use the encoding argument of open:
The same applies to writing in something other than the system default
encoding: specify the encoding argument when opening the output file.
Registering a new dialect:
A slightly more advanced use of the reader — catching and reporting errors:
And while the module doesn’t directly support parsing strings, it can easily be
done:
Footnotes
14. File Formats
14.2. configparser — Configuration file parser

    Enter search terms or a module, class or function name.
    


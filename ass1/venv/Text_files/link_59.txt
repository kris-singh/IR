URL: https://docs.python.org/3/library/datetime.html

Title: 8.1. datetime — Basic date and time types — Python 3.5.2 documentation

Doc Id: 59

Meta Tags : No meta tag found in document

Date :Jun 27, 2016

Content :Source code: Lib/datetime.py
The datetime module supplies classes for manipulating dates and times in
both simple and complex ways.  While date and time arithmetic is supported, the
focus of the implementation is on efficient attribute extraction for output
formatting and manipulation. For related functionality, see also the
time and calendar modules.
There are two kinds of date and time objects: “naive” and “aware”.
An aware object has sufficient knowledge of applicable algorithmic and
political time adjustments, such as time zone and daylight saving time
information, to locate itself relative to other aware objects.  An aware object
is used to represent a specific moment in time that is not open to
interpretation [1].
A naive object does not contain enough information to unambiguously locate
itself relative to other date/time objects.  Whether a naive object represents
Coordinated Universal Time (UTC), local time, or time in some other timezone is
purely up to the program, just like it is up to the program whether a
particular number represents metres, miles, or mass.  Naive objects are easy to
understand and to work with, at the cost of ignoring some aspects of reality.
For applications requiring aware objects, datetime and time
objects have an optional time zone information attribute, tzinfo, that
can be set to an instance of a subclass of the abstract tzinfo class.
These tzinfo objects capture information about the offset from UTC
time, the time zone name, and whether Daylight Saving Time is in effect.  Note
that only one concrete tzinfo class, the timezone class, is
supplied by the datetime module.  The timezone class can
represent simple timezones with fixed offset from UTC, such as UTC itself or
North American EST and EDT timezones.  Supporting timezones at deeper levels of
detail is up to the application.  The rules for time adjustment across the
world are more political than rational, change frequently, and there is no
standard suitable for every application aside from UTC.
The datetime module exports the following constants:
The smallest year number allowed in a date or datetime object.
MINYEAR is 1.
The largest year number allowed in a date or datetime object.
MAXYEAR is 9999.
See also
An idealized naive date, assuming the current Gregorian calendar always was, and
always will be, in effect. Attributes: year, month, and
day.
An idealized time, independent of any particular day, assuming that every day
has exactly 24*60*60 seconds (there is no notion of “leap seconds” here).
Attributes: hour, minute, second, microsecond,
and tzinfo.
A combination of a date and a time. Attributes: year, month,
day, hour, minute, second, microsecond,
and tzinfo.
A duration expressing the difference between two date, time,
or datetime instances to microsecond resolution.
An abstract base class for time zone information objects.  These are used by the
datetime and time classes to provide a customizable notion of
time adjustment (for example, to account for time zone and/or daylight saving
time).
A class that implements the tzinfo abstract base class as a
fixed offset from the UTC.
New in version 3.2.
Objects of these types are immutable.
Objects of the date type are always naive.
An object of type time or datetime may be naive or aware.
A datetime object d is aware if d.tzinfo is not None and
d.tzinfo.utcoffset(d) does not return None.  If d.tzinfo is
None, or if d.tzinfo is not None but d.tzinfo.utcoffset(d)
returns None, d is naive.  A time object t is aware
if t.tzinfo is not None and t.tzinfo.utcoffset(None) does not return
None.  Otherwise, t is naive.
The distinction between naive and aware doesn’t apply to timedelta
objects.
Subclass relationships:
A timedelta object represents a duration, the difference between two
dates or times.
All arguments are optional and default to 0.  Arguments may be integers
or floats, and may be positive or negative.
Only days, seconds and microseconds are stored internally.  Arguments are
converted to those units:
and days, seconds and microseconds are then normalized so that the
representation is unique, with
If any argument is a float and there are fractional microseconds,
the fractional microseconds left over from all arguments are
combined and their sum is rounded to the nearest microsecond using
round-half-to-even tiebreaker.  If no argument is a float, the
conversion and normalization processes are exact (no information is
lost).
If the normalized value of days lies outside the indicated range,
OverflowError is raised.
Note that normalization of negative values may be surprising at first. For
example,
Class attributes are:
The most negative timedelta object, timedelta(-999999999).
The most positive timedelta object, timedelta(days=999999999,
hours=23, minutes=59, seconds=59, microseconds=999999).
The smallest possible difference between non-equal timedelta objects,
timedelta(microseconds=1).
Note that, because of normalization, timedelta.max > -timedelta.min.
-timedelta.max is not representable as a timedelta object.
Instance attributes (read-only):
Supported operations:
Notes:
This is exact, but may overflow.
This is exact, and cannot overflow.
Division by 0 raises ZeroDivisionError.
-timedelta.max is not representable as a timedelta object.
String representations of timedelta objects are normalized
similarly to their internal representation.  This leads to somewhat
unusual results for negative timedeltas.  For example:
In addition to the operations listed above timedelta objects support
certain additions and subtractions with date and datetime
objects (see below).
Changed in version 3.2: Floor division and true division of a timedelta object by another
timedelta object are now supported, as are remainder operations and
the divmod() function.  True division and multiplication of a
timedelta object by a float object are now supported.
Comparisons of timedelta objects are supported with the
timedelta object representing the smaller duration considered to be the
smaller timedelta. In order to stop mixed-type comparisons from falling back to
the default comparison by object address, when a timedelta object is
compared to an object of a different type, TypeError is raised unless the
comparison is == or !=.  The latter cases return False or
True, respectively.
timedelta objects are hashable (usable as dictionary keys), support
efficient pickling, and in Boolean contexts, a timedelta object is
considered to be true if and only if it isn’t equal to timedelta(0).
Instance methods:
Return the total number of seconds contained in the duration. Equivalent to
td / timedelta(seconds=1).
Note that for very large time intervals (greater than 270 years on
most platforms) this method will lose microsecond accuracy.
New in version 3.2.
Example usage:
A date object represents a date (year, month and day) in an idealized
calendar, the current Gregorian calendar indefinitely extended in both
directions.  January 1 of year 1 is called day number 1, January 2 of year 1 is
called day number 2, and so on.  This matches the definition of the “proleptic
Gregorian” calendar in Dershowitz and Reingold’s book Calendrical Calculations,
where it’s the base calendar for all computations.  See the book for algorithms
for converting between proleptic Gregorian ordinals and many other calendar
systems.
All arguments are required.  Arguments may be integers, in the following
ranges:
If an argument outside those ranges is given, ValueError is raised.
Other constructors, all class methods:
Return the current local date.  This is equivalent to
date.fromtimestamp(time.time()).
Return the local date corresponding to the POSIX timestamp, such as is returned
by time.time().  This may raise OverflowError, if the timestamp is out
of the range of values supported by the platform C localtime() function,
and OSError on localtime() failure.
It’s common for this to be restricted to years from 1970 through 2038.  Note
that on non-POSIX systems that include leap seconds in their notion of a
timestamp, leap seconds are ignored by fromtimestamp().
Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp
is out of the range of values supported by the platform C
localtime() function. Raise OSError instead of
ValueError on localtime() failure.
Return the date corresponding to the proleptic Gregorian ordinal, where January
1 of year 1 has ordinal 1.  ValueError is raised unless 1 <= ordinal <=
date.max.toordinal(). For any date d, date.fromordinal(d.toordinal()) ==
d.
Class attributes:
The earliest representable date, date(MINYEAR, 1, 1).
The latest representable date, date(MAXYEAR, 12, 31).
The smallest possible difference between non-equal date objects,
timedelta(days=1).
Instance attributes (read-only):
Between MINYEAR and MAXYEAR inclusive.
Between 1 and 12 inclusive.
Between 1 and the number of days in the given month of the given year.
Supported operations:
Notes:
Dates can be used as dictionary keys. In Boolean contexts, all date
objects are considered to be true.
Instance methods:
Return a date with the same value, except for those parameters given new
values by whichever keyword arguments are specified.  For example, if d ==
date(2002, 12, 31), then d.replace(day=26) == date(2002, 12, 26).
Return a time.struct_time such as returned by time.localtime().
The hours, minutes and seconds are 0, and the DST flag is -1. d.timetuple()
is equivalent to time.struct_time((d.year, d.month, d.day, 0, 0, 0,
d.weekday(), yday, -1)), where yday = d.toordinal() - date(d.year, 1,
1).toordinal() + 1 is the day number within the current year starting with
1 for January 1st.
Return the proleptic Gregorian ordinal of the date, where January 1 of year 1
has ordinal 1.  For any date object d,
date.fromordinal(d.toordinal()) == d.
Return the day of the week as an integer, where Monday is 0 and Sunday is 6.
For example, date(2002, 12, 4).weekday() == 2, a Wednesday. See also
isoweekday().
Return the day of the week as an integer, where Monday is 1 and Sunday is 7.
For example, date(2002, 12, 4).isoweekday() == 3, a Wednesday. See also
weekday(), isocalendar().
Return a 3-tuple, (ISO year, ISO week number, ISO weekday).
The ISO calendar is a widely used variant of the Gregorian calendar. See
https://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm for a good
explanation.
The ISO year consists of 52 or 53 full weeks, and where a week starts on a
Monday and ends on a Sunday.  The first week of an ISO year is the first
(Gregorian) calendar week of a year containing a Thursday. This is called week
number 1, and the ISO year of that Thursday is the same as its Gregorian year.
For example, 2004 begins on a Thursday, so the first week of ISO year 2004
begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004, so that
date(2003, 12, 29).isocalendar() == (2004, 1, 1) and date(2004, 1,
4).isocalendar() == (2004, 1, 7).
Return a string representing the date in ISO 8601 format, ‘YYYY-MM-DD’.  For
example, date(2002, 12, 4).isoformat() == '2002-12-04'.
For a date d, str(d) is equivalent to d.isoformat().
Return a string representing the date, for example date(2002, 12,
4).ctime() == 'Wed Dec 4 00:00:00 2002'. d.ctime() is equivalent to
time.ctime(time.mktime(d.timetuple())) on platforms where the native C
ctime() function (which time.ctime() invokes, but which
date.ctime() does not invoke) conforms to the C standard.
Return a string representing the date, controlled by an explicit format string.
Format codes referring to hours, minutes or seconds will see 0 values. For a
complete list of formatting directives, see
strftime() and strptime() Behavior.
Same as date.strftime(). This makes it possible to specify a format
string for a date object when using str.format(). For a
complete list of formatting directives, see
strftime() and strptime() Behavior.
Example of counting days to an event:
Example of working with date:
A datetime object is a single object containing all the information
from a date object and a time object.  Like a date
object, datetime assumes the current Gregorian calendar extended in
both directions; like a time object, datetime assumes there are exactly
3600*24 seconds in every day.
Constructor:
The year, month and day arguments are required.  tzinfo may be None, or an
instance of a tzinfo subclass.  The remaining arguments may be integers,
in the following ranges:
If an argument outside those ranges is given, ValueError is raised.
Other constructors, all class methods:
Return the current local datetime, with tzinfo None. This is
equivalent to datetime.fromtimestamp(time.time()). See also now(),
fromtimestamp().
Return the current local date and time.  If optional argument tz is None
or not specified, this is like today(), but, if possible, supplies more
precision than can be gotten from going through a time.time() timestamp
(for example, this may be possible on platforms supplying the C
gettimeofday() function).
If tz is not None, it must be an instance of a tzinfo subclass, and the
current date and time are converted to tz’s time zone.  In this case the
result is equivalent to tz.fromutc(datetime.utcnow().replace(tzinfo=tz)).
See also today(), utcnow().
Return the current UTC date and time, with tzinfo None. This is like
now(), but returns the current UTC date and time, as a naive
datetime object.  An aware current UTC datetime can be obtained by
calling datetime.now(timezone.utc).  See also now().
Return the local date and time corresponding to the POSIX timestamp, such as is
returned by time.time(). If optional argument tz is None or not
specified, the timestamp is converted to the platform’s local date and time, and
the returned datetime object is naive.
If tz is not None, it must be an instance of a tzinfo subclass, and the
timestamp is converted to tz’s time zone.  In this case the result is
equivalent to
tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz)).
fromtimestamp() may raise OverflowError, if the timestamp is out of
the range of values supported by the platform C localtime() or
gmtime() functions, and OSError on localtime() or
gmtime() failure.
It’s common for this to be restricted to years in
1970 through 2038. Note that on non-POSIX systems that include leap seconds in
their notion of a timestamp, leap seconds are ignored by fromtimestamp(),
and then it’s possible to have two timestamps differing by a second that yield
identical datetime objects. See also utcfromtimestamp().
Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp
is out of the range of values supported by the platform C
localtime() or gmtime() functions. Raise OSError
instead of ValueError on localtime() or gmtime()
failure.
Return the UTC datetime corresponding to the POSIX timestamp, with
tzinfo None. This may raise OverflowError, if the timestamp is
out of the range of values supported by the platform C gmtime() function,
and OSError on gmtime() failure.
It’s common for this to be restricted to years in 1970 through 2038.
To get an aware datetime object, call fromtimestamp():
On the POSIX compliant platforms, it is equivalent to the following
expression:
except the latter formula always supports the full years range: between
MINYEAR and MAXYEAR inclusive.
Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp
is out of the range of values supported by the platform C
gmtime() function. Raise OSError instead of
ValueError on gmtime() failure.
Return the datetime corresponding to the proleptic Gregorian ordinal,
where January 1 of year 1 has ordinal 1. ValueError is raised unless 1
<= ordinal <= datetime.max.toordinal().  The hour, minute, second and
microsecond of the result are all 0, and tzinfo is None.
Return a new datetime object whose date components are equal to the
given date object’s, and whose time components and tzinfo
attributes are equal to the given time object’s. For any
datetime object d,
d == datetime.combine(d.date(), d.timetz()).  If date is a
datetime object, its time components and tzinfo attributes
are ignored.
Return a datetime corresponding to date_string, parsed according to
format.  This is equivalent to datetime(*(time.strptime(date_string,
format)[0:6])). ValueError is raised if the date_string and format
can’t be parsed by time.strptime() or if it returns a value which isn’t a
time tuple. For a complete list of formatting directives, see
strftime() and strptime() Behavior.
Class attributes:
The earliest representable datetime, datetime(MINYEAR, 1, 1,
tzinfo=None).
The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59,
59, 999999, tzinfo=None).
The smallest possible difference between non-equal datetime objects,
timedelta(microseconds=1).
Instance attributes (read-only):
Between MINYEAR and MAXYEAR inclusive.
Between 1 and 12 inclusive.
Between 1 and the number of days in the given month of the given year.
In range(24).
In range(60).
In range(60).
In range(1000000).
The object passed as the tzinfo argument to the datetime constructor,
or None if none was passed.
Supported operations:
datetime2 is a duration of timedelta removed from datetime1, moving forward in
time if timedelta.days > 0, or backward if timedelta.days < 0.  The
result has the same tzinfo attribute as the input datetime, and
datetime2 - datetime1 == timedelta after. OverflowError is raised if
datetime2.year would be smaller than MINYEAR or larger than
MAXYEAR. Note that no time zone adjustments are done even if the
input is an aware object.
Computes the datetime2 such that datetime2 + timedelta == datetime1. As for
addition, the result has the same tzinfo attribute as the input
datetime, and no time zone adjustments are done even if the input is aware.
This isn’t quite equivalent to datetime1 + (-timedelta), because -timedelta
in isolation can overflow in cases where datetime1 - timedelta does not.
Subtraction of a datetime from a datetime is defined only if
both operands are naive, or if both are aware.  If one is aware and the other is
naive, TypeError is raised.
If both are naive, or both are aware and have the same tzinfo attribute,
the tzinfo attributes are ignored, and the result is a timedelta
object t such that datetime2 + t == datetime1.  No time zone adjustments
are done in this case.
If both are aware and have different tzinfo attributes, a-b acts
as if a and b were first converted to naive UTC datetimes first.  The
result is (a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None)
- b.utcoffset()) except that the implementation never overflows.
datetime1 is considered less than datetime2 when datetime1 precedes
datetime2 in time.
If one comparand is naive and the other is aware, TypeError
is raised if an order comparison is attempted.  For equality
comparisons, naive instances are never equal to aware instances.
If both comparands are aware, and have the same tzinfo attribute, the
common tzinfo attribute is ignored and the base datetimes are
compared.  If both comparands are aware and have different tzinfo
attributes, the comparands are first adjusted by subtracting their UTC
offsets (obtained from self.utcoffset()).
Changed in version 3.3: Equality comparisons between naive and aware datetime
instances don’t raise TypeError.
Note
In order to stop comparison from falling back to the default scheme of comparing
object addresses, datetime comparison normally raises TypeError if the
other comparand isn’t also a datetime object.  However,
NotImplemented is returned instead if the other comparand has a
timetuple() attribute.  This hook gives other kinds of date objects a
chance at implementing mixed-type comparison.  If not, when a datetime
object is compared to an object of a different type, TypeError is raised
unless the comparison is == or !=.  The latter cases return
False or True, respectively.
datetime objects can be used as dictionary keys. In Boolean contexts,
all datetime objects are considered to be true.
Instance methods:
Return date object with same year, month and day.
Return time object with same hour, minute, second and microsecond.
tzinfo is None.  See also method timetz().
Return time object with same hour, minute, second, microsecond, and
tzinfo attributes.  See also method time().
Return a datetime with the same attributes, except for those attributes given
new values by whichever keyword arguments are specified.  Note that
tzinfo=None can be specified to create a naive datetime from an aware
datetime with no conversion of date and time data.
Return a datetime object with new tzinfo attribute tz,
adjusting the date and time data so the result is the same UTC time as
self, but in tz‘s local time.
If provided, tz must be an instance of a tzinfo subclass, and its
utcoffset() and dst() methods must not return None.  self must
be aware (self.tzinfo must not be None, and self.utcoffset() must
not return None).
If called without arguments (or with tz=None) the system local
timezone is assumed.  The .tzinfo attribute of the converted
datetime instance will be set to an instance of timezone
with the zone name and offset obtained from the OS.
If self.tzinfo is tz, self.astimezone(tz) is equal to self:  no
adjustment of date or time data is performed. Else the result is local
time in time zone tz, representing the same UTC time as self:  after
astz = dt.astimezone(tz), astz - astz.utcoffset() will usually have
the same date and time data as dt - dt.utcoffset(). The discussion
of class tzinfo explains the cases at Daylight Saving Time transition
boundaries where this cannot be achieved (an issue only if tz models both
standard and daylight time).
If you merely want to attach a time zone object tz to a datetime dt without
adjustment of date and time data, use dt.replace(tzinfo=tz).  If you
merely want to remove the time zone object from an aware datetime dt without
conversion of date and time data, use dt.replace(tzinfo=None).
Note that the default tzinfo.fromutc() method can be overridden in a
tzinfo subclass to affect the result returned by astimezone().
Ignoring error cases, astimezone() acts like:
Changed in version 3.3: tz now can be omitted.
If tzinfo is None, returns None, else returns
self.tzinfo.utcoffset(self), and raises an exception if the latter doesn’t
return None, or a timedelta object representing a whole number of
minutes with magnitude less than one day.
If tzinfo is None, returns None, else returns
self.tzinfo.dst(self), and raises an exception if the latter doesn’t return
None, or a timedelta object representing a whole number of minutes
with magnitude less than one day.
If tzinfo is None, returns None, else returns
self.tzinfo.tzname(self), raises an exception if the latter doesn’t return
None or a string object,
Return a time.struct_time such as returned by time.localtime().
d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day,
d.hour, d.minute, d.second, d.weekday(), yday, dst)), where yday =
d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within
the current year starting with 1 for January 1st. The tm_isdst flag
of the result is set according to the dst() method: tzinfo is
None or dst() returns None, tm_isdst is set to -1;
else if dst() returns a non-zero value, tm_isdst is set to 1;
else tm_isdst is set to 0.
If datetime instance d is naive, this is the same as
d.timetuple() except that tm_isdst is forced to 0 regardless of what
d.dst() returns.  DST is never in effect for a UTC time.
If d is aware, d is normalized to UTC time, by subtracting
d.utcoffset(), and a time.struct_time for the
normalized time is returned.  tm_isdst is forced to 0. Note
that an OverflowError may be raised if d.year was
MINYEAR or MAXYEAR and UTC adjustment spills over a year
boundary.
Return the proleptic Gregorian ordinal of the date.  The same as
self.date().toordinal().
Return POSIX timestamp corresponding to the datetime
instance.  The return value is a float similar to that
returned by time.time().
Naive datetime instances are assumed to represent local
time and this method relies on the platform C mktime()
function to perform the conversion.  Since datetime
supports wider range of values than mktime() on many
platforms, this method may raise OverflowError for times far
in the past or far in the future.
For aware datetime instances, the return value is computed
as:
New in version 3.3.
Note
There is no method to obtain the POSIX timestamp directly from a
naive datetime instance representing UTC time.  If your
application uses this convention and your system timezone is not
set to UTC, you can obtain the POSIX timestamp by supplying
tzinfo=timezone.utc:
or by calculating the timestamp directly:
Return the day of the week as an integer, where Monday is 0 and Sunday is 6.
The same as self.date().weekday(). See also isoweekday().
Return the day of the week as an integer, where Monday is 1 and Sunday is 7.
The same as self.date().isoweekday(). See also weekday(),
isocalendar().
Return a 3-tuple, (ISO year, ISO week number, ISO weekday).  The same as
self.date().isocalendar().
Return a string representing the date and time in ISO 8601 format,
YYYY-MM-DDTHH:MM:SS.mmmmmm or, if microsecond is 0,
YYYY-MM-DDTHH:MM:SS
If utcoffset() does not return None, a 6-character string is
appended, giving the UTC offset in (signed) hours and minutes:
YYYY-MM-DDTHH:MM:SS.mmmmmm+HH:MM or, if microsecond is 0
YYYY-MM-DDTHH:MM:SS+HH:MM
The optional argument sep (default 'T') is a one-character separator,
placed between the date and time portions of the result.  For example,
For a datetime instance d, str(d) is equivalent to
d.isoformat(' ').
Return a string representing the date and time, for example datetime(2002, 12,
4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40 2002'. d.ctime() is
equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the
native C ctime() function (which time.ctime() invokes, but which
datetime.ctime() does not invoke) conforms to the C standard.
Return a string representing the date and time, controlled by an explicit format
string.  For a complete list of formatting directives, see
strftime() and strptime() Behavior.
Same as datetime.strftime().  This makes it possible to specify a format
string for a datetime object when using str.format().  For a
complete list of formatting directives, see
strftime() and strptime() Behavior.
Examples of working with datetime objects:
Using datetime with tzinfo:
A time object represents a (local) time of day, independent of any particular
day, and subject to adjustment via a tzinfo object.
All arguments are optional.  tzinfo may be None, or an instance of a
tzinfo subclass.  The remaining arguments may be integers, in the
following ranges:
If an argument outside those ranges is given, ValueError is raised.  All
default to 0 except tzinfo, which defaults to None.
Class attributes:
The earliest representable time, time(0, 0, 0, 0).
The latest representable time, time(23, 59, 59, 999999).
The smallest possible difference between non-equal time objects,
timedelta(microseconds=1), although note that arithmetic on
time objects is not supported.
Instance attributes (read-only):
In range(24).
In range(60).
In range(60).
In range(1000000).
The object passed as the tzinfo argument to the time constructor, or
None if none was passed.
Supported operations:
comparison of time to time, where a is considered less
than b when a precedes b in time.  If one comparand is naive and the other
is aware, TypeError is raised if an order comparison is attempted. For equality
comparisons, naive instances are never equal to aware instances.
If both comparands are aware, and have
the same tzinfo attribute, the common tzinfo attribute is
ignored and the base times are compared.  If both comparands are aware and
have different tzinfo attributes, the comparands are first adjusted by
subtracting their UTC offsets (obtained from self.utcoffset()). In order
to stop mixed-type comparisons from falling back to the default comparison by
object address, when a time object is compared to an object of a
different type, TypeError is raised unless the comparison is == or
!=.  The latter cases return False or True, respectively.
Changed in version 3.3: Equality comparisons between naive and aware time instances
don’t raise TypeError.
hash, use as dict key
efficient pickling
In boolean contexts, a time object is always considered to be true.
Changed in version 3.5: Before Python 3.5, a time object was considered to be false if it
represented midnight in UTC.  This behavior was considered obscure and
error-prone and has been removed in Python 3.5.  See issue 13936 for full
details.
Instance methods:
Return a time with the same value, except for those attributes given
new values by whichever keyword arguments are specified.  Note that
tzinfo=None can be specified to create a naive time from an
aware time, without conversion of the time data.
Return a string representing the time in ISO 8601 format, HH:MM:SS.mmmmmm or, if
self.microsecond is 0, HH:MM:SS If utcoffset() does not return None, a
6-character string is appended, giving the UTC offset in (signed) hours and
minutes: HH:MM:SS.mmmmmm+HH:MM or, if self.microsecond is 0, HH:MM:SS+HH:MM
For a time t, str(t) is equivalent to t.isoformat().
Return a string representing the time, controlled by an explicit format
string.  For a complete list of formatting directives, see
strftime() and strptime() Behavior.
Same as time.strftime(). This makes it possible to specify a format string
for a time object when using str.format().  For a
complete list of formatting directives, see
strftime() and strptime() Behavior.
If tzinfo is None, returns None, else returns
self.tzinfo.utcoffset(None), and raises an exception if the latter doesn’t
return None or a timedelta object representing a whole number of
minutes with magnitude less than one day.
If tzinfo is None, returns None, else returns
self.tzinfo.dst(None), and raises an exception if the latter doesn’t return
None, or a timedelta object representing a whole number of minutes
with magnitude less than one day.
If tzinfo is None, returns None, else returns
self.tzinfo.tzname(None), or raises an exception if the latter doesn’t
return None or a string object.
Example:
This is an abstract base class, meaning that this class should not be
instantiated directly.  You need to derive a concrete subclass, and (at least)
supply implementations of the standard tzinfo methods needed by the
datetime methods you use.  The datetime module supplies
a simple concrete subclass of tzinfo, timezone, which can represent
timezones with fixed offset from UTC such as UTC itself or North American EST and
EDT.
An instance of (a concrete subclass of) tzinfo can be passed to the
constructors for datetime and time objects. The latter objects
view their attributes as being in local time, and the tzinfo object
supports methods revealing offset of local time from UTC, the name of the time
zone, and DST offset, all relative to a date or time object passed to them.
Special requirement for pickling:  A tzinfo subclass must have an
__init__() method that can be called with no arguments, else it can be
pickled but possibly not unpickled again.  This is a technical requirement that
may be relaxed in the future.
A concrete subclass of tzinfo may need to implement the following
methods.  Exactly which methods are needed depends on the uses made of aware
datetime objects.  If in doubt, simply implement all of them.
Return offset of local time from UTC, in minutes east of UTC.  If local time is
west of UTC, this should be negative.  Note that this is intended to be the
total offset from UTC; for example, if a tzinfo object represents both
time zone and DST adjustments, utcoffset() should return their sum.  If
the UTC offset isn’t known, return None.  Else the value returned must be a
timedelta object specifying a whole number of minutes in the range
-1439 to 1439 inclusive (1440 = 24*60; the magnitude of the offset must be less
than one day).  Most implementations of utcoffset() will probably look
like one of these two:
If utcoffset() does not return None, dst() should not return
None either.
The default implementation of utcoffset() raises
NotImplementedError.
Return the daylight saving time (DST) adjustment, in minutes east of UTC, or
None if DST information isn’t known.  Return timedelta(0) if DST is not
in effect. If DST is in effect, return the offset as a timedelta object
(see utcoffset() for details). Note that DST offset, if applicable, has
already been added to the UTC offset returned by utcoffset(), so there’s
no need to consult dst() unless you’re interested in obtaining DST info
separately.  For example, datetime.timetuple() calls its tzinfo
attribute’s dst() method to determine how the tm_isdst flag
should be set, and tzinfo.fromutc() calls dst() to account for
DST changes when crossing time zones.
An instance tz of a tzinfo subclass that models both standard and
daylight times must be consistent in this sense:
tz.utcoffset(dt) - tz.dst(dt)
must return the same result for every datetime dt with dt.tzinfo ==
tz  For sane tzinfo subclasses, this expression yields the time
zone’s “standard offset”, which should not depend on the date or the time, but
only on geographic location.  The implementation of datetime.astimezone()
relies on this, but cannot detect violations; it’s the programmer’s
responsibility to ensure it.  If a tzinfo subclass cannot guarantee
this, it may be able to override the default implementation of
tzinfo.fromutc() to work correctly with astimezone() regardless.
Most implementations of dst() will probably look like one of these two:
or
The default implementation of dst() raises NotImplementedError.
Return the time zone name corresponding to the datetime object dt, as
a string. Nothing about string names is defined by the datetime module,
and there’s no requirement that it mean anything in particular.  For example,
“GMT”, “UTC”, “-500”, “-5:00”, “EDT”, “US/Eastern”, “America/New York” are all
valid replies.  Return None if a string name isn’t known.  Note that this is
a method rather than a fixed string primarily because some tzinfo
subclasses will wish to return different names depending on the specific value
of dt passed, especially if the tzinfo class is accounting for
daylight time.
The default implementation of tzname() raises NotImplementedError.
These methods are called by a datetime or time object, in
response to their methods of the same names.  A datetime object passes
itself as the argument, and a time object passes None as the
argument.  A tzinfo subclass’s methods should therefore be prepared to
accept a dt argument of None, or of class datetime.
When None is passed, it’s up to the class designer to decide the best
response.  For example, returning None is appropriate if the class wishes to
say that time objects don’t participate in the tzinfo protocols.  It
may be more useful for utcoffset(None) to return the standard UTC offset, as
there is no other convention for discovering the standard offset.
When a datetime object is passed in response to a datetime
method, dt.tzinfo is the same object as self.  tzinfo methods can
rely on this, unless user code calls tzinfo methods directly.  The
intent is that the tzinfo methods interpret dt as being in local
time, and not need worry about objects in other timezones.
There is one more tzinfo method that a subclass may wish to override:
This is called from the default datetime.astimezone()
implementation.  When called from that, dt.tzinfo is self, and dt‘s
date and time data are to be viewed as expressing a UTC time.  The purpose
of fromutc() is to adjust the date and time data, returning an
equivalent datetime in self‘s local time.
Most tzinfo subclasses should be able to inherit the default
fromutc() implementation without problems.  It’s strong enough to handle
fixed-offset time zones, and time zones accounting for both standard and
daylight time, and the latter even if the DST transition times differ in
different years.  An example of a time zone the default fromutc()
implementation may not handle correctly in all cases is one where the standard
offset (from UTC) depends on the specific date and time passed, which can happen
for political reasons. The default implementations of astimezone() and
fromutc() may not produce the result you want if the result is one of the
hours straddling the moment the standard offset changes.
Skipping code for error cases, the default fromutc() implementation acts
like:
Example tzinfo classes:
Note that there are unavoidable subtleties twice per year in a tzinfo
subclass accounting for both standard and daylight time, at the DST transition
points.  For concreteness, consider US Eastern (UTC -0500), where EDT begins the
minute after 1:59 (EST) on the second Sunday in March, and ends the minute after
1:59 (EDT) on the first Sunday in November:
When DST starts (the “start” line), the local wall clock leaps from 1:59 to
3:00.  A wall time of the form 2:MM doesn’t really make sense on that day, so
astimezone(Eastern) won’t deliver a result with hour == 2 on the day DST
begins.  In order for astimezone() to make this guarantee, the
tzinfo.dst() method must consider times in the “missing hour” (2:MM for
Eastern) to be in daylight time.
When DST ends (the “end” line), there’s a potentially worse problem: there’s an
hour that can’t be spelled unambiguously in local wall time: the last hour of
daylight time.  In Eastern, that’s times of the form 5:MM UTC on the day
daylight time ends.  The local wall clock leaps from 1:59 (daylight time) back
to 1:00 (standard time) again. Local times of the form 1:MM are ambiguous.
astimezone() mimics the local clock’s behavior by mapping two adjacent UTC
hours into the same local hour then.  In the Eastern example, UTC times of the
form 5:MM and 6:MM both map to 1:MM when converted to Eastern.  In order for
astimezone() to make this guarantee, the tzinfo.dst() method must
consider times in the “repeated hour” to be in standard time.  This is easily
arranged, as in the example, by expressing DST switch times in the time zone’s
standard local time.
Applications that can’t bear such ambiguities should avoid using hybrid
tzinfo subclasses; there are no ambiguities when using timezone,
or any other fixed-offset tzinfo subclass (such as a class representing
only EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours)).
See also
The standard library has timezone class for handling arbitrary
fixed offsets from UTC and timezone.utc as UTC timezone instance.
pytz library brings the IANA timezone database (also known as the
Olson database) to Python and its usage is recommended.
The timezone class is a subclass of tzinfo, each
instance of which represents a timezone defined by a fixed offset from
UTC.  Note that objects of this class cannot be used to represent
timezone information in the locations where different offsets are used
in different days of the year or where historical changes have been
made to civil time.
The offset argument must be specified as a timedelta
object representing the difference between the local time and UTC.  It must
be strictly between -timedelta(hours=24) and
timedelta(hours=24) and represent a whole number of minutes,
otherwise ValueError is raised.
The name argument is optional.  If specified it must be a string that
is used as the value returned by the tzname(dt) method.  Otherwise,
tzname(dt) returns a string ‘UTCsHH:MM’, where s is the sign of
offset, HH and MM are two digits of offset.hours and
offset.minutes respectively.
New in version 3.2.
Return the fixed value specified when the timezone instance is
constructed.  The dt argument is ignored.  The return value is a
timedelta instance equal to the difference between the
local time and UTC.
Return the fixed value specified when the timezone instance is
constructed or a string ‘UTCsHH:MM’, where s is the sign of
offset, HH and MM are two digits of offset.hours and
offset.minutes respectively.
Always returns None.
Return dt + offset.  The dt argument must be an aware
datetime instance, with tzinfo set to self.
Class attributes:
The UTC timezone, timezone(timedelta(0)).
date, datetime, and time objects all support a
strftime(format) method, to create a string representing the time under the
control of an explicit format string.  Broadly speaking, d.strftime(fmt)
acts like the time module’s time.strftime(fmt, d.timetuple())
although not all objects support a timetuple() method.
Conversely, the datetime.strptime() class method creates a
datetime object from a string representing a date and time and a
corresponding format string. datetime.strptime(date_string, format) is
equivalent to datetime(*(time.strptime(date_string, format)[0:6])).
For time objects, the format codes for year, month, and day should not
be used, as time objects have no such values.  If they’re used anyway, 1900
is substituted for the year, and 1 for the month and day.
For date objects, the format codes for hours, minutes, seconds, and
microseconds should not be used, as date objects have no such
values.  If they’re used anyway, 0 is substituted for them.
The full set of format codes supported varies across platforms, because Python
calls the platform C library’s strftime() function, and platform
variations are common.  To see the full set of format codes supported on your
platform, consult the strftime(3) documentation.
The following is a list of all the format codes that the C standard (1989
version) requires, and these work on all platforms with a standard C
implementation.  Note that the 1999 version of the C standard added additional
format codes.
Notes:
Because the format depends on the current locale, care should be taken when
making assumptions about the output value. Field orderings will vary (for
example, “month/day/year” versus “day/month/year”), and the output may
contain Unicode characters encoded using the locale’s default encoding (for
example, if the current locale is ja_JP, the default encoding could be
any one of eucJP, SJIS, or utf-8; use locale.getlocale()
to determine the current locale’s encoding).
The strptime() method can parse years in the full [1, 9999] range, but
years < 1000 must be zero-filled to 4-digit width.
Changed in version 3.2: In previous versions, strftime() method was restricted to
years >= 1900.
Changed in version 3.3: In version 3.2, strftime() method was restricted to
years >= 1000.
When used with the strptime() method, the %p directive only affects
the output hour field if the %I directive is used to parse the hour.
Unlike the time module, the datetime module does not support
leap seconds.
When used with the strptime() method, the %f directive
accepts from one to six digits and zero pads on the right.  %f is
an extension to the set of format characters in the C standard (but
implemented separately in datetime objects, and therefore always
available).
For a naive object, the %z and %Z format codes are replaced by empty
strings.
For an aware object:
utcoffset() is transformed into a 5-character string of the form
+HHMM or -HHMM, where HH is a 2-digit string giving the number of UTC
offset hours, and MM is a 2-digit string giving the number of UTC offset
minutes.  For example, if utcoffset() returns
timedelta(hours=-3, minutes=-30), %z is replaced with the string
'-0330'.
If tzname() returns None, %Z is replaced by an empty
string.  Otherwise %Z is replaced by the returned value, which must
be a string.
Changed in version 3.2: When the %z directive is provided to the strptime() method, an
aware datetime object will be produced.  The tzinfo of the
result will be set to a timezone instance.
When used with the strptime() method, %U and %W are only used
in calculations when the day of the week and the year are specified.
Footnotes
8. Data Types
8.2. calendar — General calendar-related functions

    Enter search terms or a module, class or function name.
    


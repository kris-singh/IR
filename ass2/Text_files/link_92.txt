URL: https://docs.python.org/3/library/pickle.html

Title: 12.1. pickle — Python object serialization — Python 3.5.2 documentation

Doc Id: 92

Meta Tags : No meta tag found in document

Date :Jun 27, 2016

Content :Source code: Lib/pickle.py
The pickle module implements binary protocols for serializing and
de-serializing a Python object structure.  “Pickling” is the process
whereby a Python object hierarchy is converted into a byte stream, and
“unpickling” is the inverse operation, whereby a byte stream
(from a binary file or bytes-like object) is converted
back into an object hierarchy.  Pickling (and unpickling) is alternatively
known as “serialization”, “marshalling,” [1] or “flattening”; however, to
avoid confusion, the terms used here are “pickling” and “unpickling”.
Warning
The pickle module is not secure against erroneous or maliciously
constructed data.  Never unpickle data received from an untrusted or
unauthenticated source.
Python has a more primitive serialization module called marshal, but in
general pickle should always be the preferred way to serialize Python
objects.  marshal exists primarily to support Python’s .pyc
files.
The pickle module differs from marshal in several significant ways:
The pickle module keeps track of the objects it has already serialized,
so that later references to the same object won’t be serialized again.
marshal doesn’t do this.
This has implications both for recursive objects and object sharing.  Recursive
objects are objects that contain references to themselves.  These are not
handled by marshal, and in fact, attempting to marshal recursive objects will
crash your Python interpreter.  Object sharing happens when there are multiple
references to the same object in different places in the object hierarchy being
serialized.  pickle stores such objects only once, and ensures that all
other references point to the master copy.  Shared objects remain shared, which
can be very important for mutable objects.
marshal cannot be used to serialize user-defined classes and their
instances.  pickle can save and restore class instances transparently,
however the class definition must be importable and live in the same module as
when the object was stored.
The marshal serialization format is not guaranteed to be portable
across Python versions.  Because its primary job in life is to support
.pyc files, the Python implementers reserve the right to change the
serialization format in non-backwards compatible ways should the need arise.
The pickle serialization format is guaranteed to be backwards compatible
across Python releases.
There are fundamental differences between the pickle protocols and
JSON (JavaScript Object Notation):
See also
The json module: a standard library module allowing JSON
serialization and deserialization.
The data format used by pickle is Python-specific.  This has the
advantage that there are no restrictions imposed by external standards such as
JSON or XDR (which can’t represent pointer sharing); however it means that
non-Python programs may not be able to reconstruct pickled Python objects.
By default, the pickle data format uses a relatively compact binary
representation.  If you need optimal size characteristics, you can efficiently
compress pickled data.
The module pickletools contains tools for analyzing data streams
generated by pickle.  pickletools source code has extensive
comments about opcodes used by pickle protocols.
There are currently 5 different protocols which can be used for pickling.
The higher the protocol used, the more recent the version of Python needed
to read the pickle produced.
Note
Serialization is a more primitive notion than persistence; although
pickle reads and writes file objects, it does not handle the issue of
naming persistent objects, nor the (even more complicated) issue of concurrent
access to persistent objects.  The pickle module can transform a complex
object into a byte stream and it can transform the byte stream into an object
with the same internal structure.  Perhaps the most obvious thing to do with
these byte streams is to write them onto a file, but it is also conceivable to
send them across a network or store them in a database.  The shelve
module provides a simple interface to pickle and unpickle objects on
DBM-style database files.
To serialize an object hierarchy, you simply call the dumps() function.
Similarly, to de-serialize a data stream, you call the loads() function.
However, if you want more control over serialization and de-serialization,
you can create a Pickler or an Unpickler object, respectively.
The pickle module provides the following constants:
An integer, the highest protocol version
available.  This value can be passed as a protocol value to functions
dump() and dumps() as well as the Pickler
constructor.
An integer, the default protocol version used
for pickling.  May be less than HIGHEST_PROTOCOL.  Currently the
default protocol is 3, a new protocol designed for Python 3.
The pickle module provides the following functions to make the pickling
process more convenient:
Write a pickled representation of obj to the open file object file.
This is equivalent to Pickler(file, protocol).dump(obj).
The optional protocol argument, an integer, tells the pickler to use
the given protocol; supported protocols are 0 to HIGHEST_PROTOCOL.
If not specified, the default is DEFAULT_PROTOCOL.  If a negative
number is specified, HIGHEST_PROTOCOL is selected.
The file argument must have a write() method that accepts a single bytes
argument.  It can thus be an on-disk file opened for binary writing, an
io.BytesIO instance, or any other custom object that meets this
interface.
If fix_imports is true and protocol is less than 3, pickle will try to
map the new Python 3 names to the old module names used in Python 2, so
that the pickle data stream is readable with Python 2.
Return the pickled representation of the object as a bytes object,
instead of writing it to a file.
Arguments protocol and fix_imports have the same meaning as in
dump().
Read a pickled object representation from the open file object
file and return the reconstituted object hierarchy specified therein.
This is equivalent to Unpickler(file).load().
The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object’s
representation are ignored.
The argument file must have two methods, a read() method that takes an
integer argument, and a readline() method that requires no arguments.  Both
methods should return bytes.  Thus file can be an on-disk file opened for
binary reading, an io.BytesIO object, or any other custom object
that meets this interface.
Optional keyword arguments are fix_imports, encoding and errors,
which are used to control compatibility support for pickle stream generated
by Python 2.  If fix_imports is true, pickle will try to map the old
Python 2 names to the new names used in Python 3.  The encoding and
errors tell pickle how to decode 8-bit string instances pickled by Python
2; these default to ‘ASCII’ and ‘strict’, respectively.  The encoding can
be ‘bytes’ to read these 8-bit string instances as bytes objects.
Read a pickled object hierarchy from a bytes object and return the
reconstituted object hierarchy specified therein.
The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object’s
representation are ignored.
Optional keyword arguments are fix_imports, encoding and errors,
which are used to control compatibility support for pickle stream generated
by Python 2.  If fix_imports is true, pickle will try to map the old
Python 2 names to the new names used in Python 3.  The encoding and
errors tell pickle how to decode 8-bit string instances pickled by Python
2; these default to ‘ASCII’ and ‘strict’, respectively.  The encoding can
be ‘bytes’ to read these 8-bit string instances as bytes objects.
The pickle module defines three exceptions:
Common base class for the other pickling exceptions.  It inherits
Exception.
Error raised when an unpicklable object is encountered by Pickler.
It inherits PickleError.
Refer to What can be pickled and unpickled? to learn what kinds of objects can be
pickled.
Error raised when there is a problem unpickling an object, such as a data
corruption or a security violation.  It inherits PickleError.
Note that other exceptions may also be raised during unpickling, including
(but not necessarily limited to) AttributeError, EOFError, ImportError, and
IndexError.
The pickle module exports two classes, Pickler and
Unpickler:
This takes a binary file for writing a pickle data stream.
The optional protocol argument, an integer, tells the pickler to use
the given protocol; supported protocols are 0 to HIGHEST_PROTOCOL.
If not specified, the default is DEFAULT_PROTOCOL.  If a negative
number is specified, HIGHEST_PROTOCOL is selected.
The file argument must have a write() method that accepts a single bytes
argument.  It can thus be an on-disk file opened for binary writing, an
io.BytesIO instance, or any other custom object that meets this
interface.
If fix_imports is true and protocol is less than 3, pickle will try to
map the new Python 3 names to the old module names used in Python 2, so
that the pickle data stream is readable with Python 2.
Write a pickled representation of obj to the open file object given in
the constructor.
Do nothing by default.  This exists so a subclass can override it.
If persistent_id() returns None, obj is pickled as usual.  Any
other value causes Pickler to emit the returned value as a
persistent ID for obj.  The meaning of this persistent ID should be
defined by Unpickler.persistent_load().  Note that the value
returned by persistent_id() cannot itself have a persistent ID.
See Persistence of External Objects for details and examples of uses.
A pickler object’s dispatch table is a registry of reduction
functions of the kind which can be declared using
copyreg.pickle().  It is a mapping whose keys are classes
and whose values are reduction functions.  A reduction function
takes a single argument of the associated class and should
conform to the same interface as a __reduce__()
method.
By default, a pickler object will not have a
dispatch_table attribute, and it will instead use the
global dispatch table managed by the copyreg module.
However, to customize the pickling for a specific pickler object
one can set the dispatch_table attribute to a dict-like
object.  Alternatively, if a subclass of Pickler has a
dispatch_table attribute then this will be used as the
default dispatch table for instances of that class.
See Dispatch Tables for usage examples.
New in version 3.3.
Deprecated. Enable fast mode if set to a true value.  The fast mode
disables the usage of memo, therefore speeding the pickling process by not
generating superfluous PUT opcodes.  It should not be used with
self-referential objects, doing otherwise will cause Pickler to
recurse infinitely.
Use pickletools.optimize() if you need more compact pickles.
This takes a binary file for reading a pickle data stream.
The protocol version of the pickle is detected automatically, so no
protocol argument is needed.
The argument file must have two methods, a read() method that takes an
integer argument, and a readline() method that requires no arguments.  Both
methods should return bytes.  Thus file can be an on-disk file object
opened for binary reading, an io.BytesIO object, or any other
custom object that meets this interface.
Optional keyword arguments are fix_imports, encoding and errors,
which are used to control compatibility support for pickle stream generated
by Python 2.  If fix_imports is true, pickle will try to map the old
Python 2 names to the new names used in Python 3.  The encoding and
errors tell pickle how to decode 8-bit string instances pickled by Python
2; these default to ‘ASCII’ and ‘strict’, respectively.  The encoding can
be ‘bytes’ to read these ß8-bit string instances as bytes objects.
Read a pickled object representation from the open file object given in
the constructor, and return the reconstituted object hierarchy specified
therein.  Bytes past the pickled object’s representation are ignored.
Raise an UnpicklingError by default.
If defined, persistent_load() should return the object specified by
the persistent ID pid.  If an invalid persistent ID is encountered, an
UnpicklingError should be raised.
See Persistence of External Objects for details and examples of uses.
Import module if necessary and return the object called name from it,
where the module and name arguments are str objects.  Note,
unlike its name suggests, find_class() is also used for finding
functions.
Subclasses may override this to gain control over what type of objects and
how they can be loaded, potentially reducing security risks. Refer to
Restricting Globals for details.
The following types can be pickled:
Attempts to pickle unpicklable objects will raise the PicklingError
exception; when this happens, an unspecified number of bytes may have already
been written to the underlying file.  Trying to pickle a highly recursive data
structure may exceed the maximum recursion depth, a RecursionError will be
raised in this case.  You can carefully raise this limit with
sys.setrecursionlimit().
Note that functions (built-in and user-defined) are pickled by “fully qualified”
name reference, not by value. [2]  This means that only the function name is
pickled, along with the name of the module the function is defined in.  Neither
the function’s code, nor any of its function attributes are pickled.  Thus the
defining module must be importable in the unpickling environment, and the module
must contain the named object, otherwise an exception will be raised. [3]
Similarly, classes are pickled by named reference, so the same restrictions in
the unpickling environment apply.  Note that none of the class’s code or data is
pickled, so in the following example the class attribute attr is not
restored in the unpickling environment:
These restrictions are why picklable functions and classes must be defined in
the top level of a module.
Similarly, when class instances are pickled, their class’s code and data are not
pickled along with them.  Only the instance data are pickled.  This is done on
purpose, so you can fix bugs in a class or add methods to the class and still
load objects that were created with an earlier version of the class.  If you
plan to have long-lived objects that will see many versions of a class, it may
be worthwhile to put a version number in the objects so that suitable
conversions can be made by the class’s __setstate__() method.
In this section, we describe the general mechanisms available to you to define,
customize, and control how class instances are pickled and unpickled.
In most cases, no additional code is needed to make instances picklable.  By
default, pickle will retrieve the class and the attributes of an instance via
introspection. When a class instance is unpickled, its __init__() method
is usually not invoked.  The default behaviour first creates an uninitialized
instance and then restores the saved attributes.  The following code shows an
implementation of this behaviour:
Classes can alter the default behaviour by providing one or several special
methods:
In protocols 4 and newer, classes that implements the
__getnewargs_ex__() method can dictate the values passed to the
__new__() method upon unpickling.  The method must return a pair
(args, kwargs) where args is a tuple of positional arguments
and kwargs a dictionary of named arguments for constructing the
object.  Those will be passed to the __new__() method upon
unpickling.
You should implement this method if the __new__() method of your
class requires keyword-only arguments.  Otherwise, it is recommended for
compatibility to implement __getnewargs__().
This method serve a similar purpose as __getnewargs_ex__() but
for protocols 2 and newer.  It must return a tuple of arguments args
which will be passed to the __new__() method upon unpickling.
In protocols 4 and newer, __getnewargs__() will not be called if
__getnewargs_ex__() is defined.
Classes can further influence how their instances are pickled; if the class
defines the method __getstate__(), it is called and the returned object
is pickled as the contents for the instance, instead of the contents of the
instance’s dictionary.  If the __getstate__() method is absent, the
instance’s __dict__ is pickled as usual.
Upon unpickling, if the class defines __setstate__(), it is called with
the unpickled state.  In that case, there is no requirement for the state
object to be a dictionary.  Otherwise, the pickled state must be a dictionary
and its items are assigned to the new instance’s dictionary.
Note
If __getstate__() returns a false value, the __setstate__()
method will not be called upon unpickling.
Refer to the section Handling Stateful Objects for more information about how to use
the methods __getstate__() and __setstate__().
Note
At unpickling time, some methods like __getattr__(),
__getattribute__(), or __setattr__() may be called upon the
instance.  In case those methods rely on some internal invariant being
true, the type should implement __getnewargs__() or
__getnewargs_ex__() to establish such an invariant; otherwise,
neither __new__() nor __init__() will be called.
As we shall see, pickle does not use directly the methods described above.  In
fact, these methods are part of the copy protocol which implements the
__reduce__() special method.  The copy protocol provides a unified
interface for retrieving the data necessary for pickling and copying
objects. [4]
Although powerful, implementing __reduce__() directly in your classes is
error prone.  For this reason, class designers should use the high-level
interface (i.e., __getnewargs_ex__(), __getstate__() and
__setstate__()) whenever possible.  We will show, however, cases where
using __reduce__() is the only option or leads to more efficient pickling
or both.
The interface is currently defined as follows.  The __reduce__() method
takes no argument and shall return either a string or preferably a tuple (the
returned object is often referred to as the “reduce value”).
If a string is returned, the string should be interpreted as the name of a
global variable.  It should be the object’s local name relative to its
module; the pickle module searches the module namespace to determine the
object’s module.  This behaviour is typically useful for singletons.
When a tuple is returned, it must be between two and five items long.
Optional items can either be omitted, or None can be provided as their
value.  The semantics of each item are in order:
Alternatively, a __reduce_ex__() method may be defined.  The only
difference is this method should take a single integer argument, the protocol
version.  When defined, pickle will prefer it over the __reduce__()
method.  In addition, __reduce__() automatically becomes a synonym for
the extended version.  The main use for this method is to provide
backwards-compatible reduce values for older Python releases.
For the benefit of object persistence, the pickle module supports the
notion of a reference to an object outside the pickled data stream.  Such
objects are referenced by a persistent ID, which should be either a string of
alphanumeric characters (for protocol 0) [5] or just an arbitrary object (for
any newer protocol).
The resolution of such persistent IDs is not defined by the pickle
module; it will delegate this resolution to the user defined methods on the
pickler and unpickler, persistent_id() and
persistent_load() respectively.
To pickle objects that have an external persistent id, the pickler must have a
custom persistent_id() method that takes an object as an
argument and returns either None or the persistent id for that object.
When None is returned, the pickler simply pickles the object as normal.
When a persistent ID string is returned, the pickler will pickle that object,
along with a marker so that the unpickler will recognize it as a persistent ID.
To unpickle external objects, the unpickler must have a custom
persistent_load() method that takes a persistent ID object and
returns the referenced object.
Here is a comprehensive example presenting how persistent ID can be used to
pickle external objects by reference.
If one wants to customize pickling of some classes without disturbing
any other code which depends on pickling, then one can create a
pickler with a private dispatch table.
The global dispatch table managed by the copyreg module is
available as copyreg.dispatch_table.  Therefore, one may
choose to use a modified copy of copyreg.dispatch_table as a
private dispatch table.
For example
creates an instance of pickle.Pickler with a private dispatch
table which handles the SomeClass class specially.  Alternatively,
the code
does the same, but all instances of MyPickler will by default
share the same dispatch table.  The equivalent code using the
copyreg module is
Here’s an example that shows how to modify pickling behavior for a class.
The TextReader class opens a text file, and returns the line number and
line contents each time its readline() method is called. If a
TextReader instance is pickled, all attributes except the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The __setstate__() and
__getstate__() methods are used to implement this behavior.
A sample usage might be something like this:
By default, unpickling will import any class or function that it finds in the
pickle data.  For many applications, this behaviour is unacceptable as it
permits the unpickler to import and invoke arbitrary code.  Just consider what
this hand-crafted pickle data stream does when loaded:
In this example, the unpickler imports the os.system() function and then
apply the string argument “echo hello world”.  Although this example is
inoffensive, it is not difficult to imagine one that could damage your system.
For this reason, you may want to control what gets unpickled by customizing
Unpickler.find_class().  Unlike its name suggests,
Unpickler.find_class() is called whenever a global (i.e., a class or
a function) is requested.  Thus it is possible to either completely forbid
globals or restrict them to a safe subset.
Here is an example of an unpickler allowing only few safe classes from the
builtins module to be loaded:
A sample usage of our unpickler working has intended:
As our examples shows, you have to be careful with what you allow to be
unpickled.  Therefore if security is a concern, you may want to consider
alternatives such as the marshalling API in xmlrpc.client or
third-party solutions.
Recent versions of the pickle protocol (from protocol 2 and upwards) feature
efficient binary encodings for several common features and built-in types.
Also, the pickle module has a transparent optimizer written in C.
For the simplest code, use the dump() and load() functions.
The following example reads the resulting pickled data.
See also
Footnotes
12. Data Persistence
12.2. copyreg — Register pickle support functions

    Enter search terms or a module, class or function name.
    

